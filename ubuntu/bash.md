### Bash commands

|Command|Action|
|------|--------|
|break| выход из цикла for, while или until|
|continue| выполнение следующей итерации цикла for, while или until|
|echo| вывод аргументов, разделенных пробелами, на стандартное устройство вывода|
|exit| выход из оболочки|
|export| отмечает аргументы как переменные для передачи в дочерние процессы в среде|
|hash| запоминает полные имена путей команд, указанных в качестве аргументов, чтобы не искать их при следующем обращении|
|kill| посылает сигнал завершения процессу|
|pwd| выводит текущий рабочий каталог|
|read| читает строку из ввода оболочки и использует ее для присвоения значений указанным переменным.\|
|return| заставляет функцию оболочки выйти с указанным значением|
|shift| перемещает позиционные параметры налево|
|test| вычисляет условное выражение|
|times| выводит имя пользователя и системное время, использованное оболочкой и ее потомками|
|trap| указывает команды, которые должны выполняться при получении оболочкой сигнала|
|unset| вызывает уничтожение переменных оболочки|
|wait| ждет выхода из дочернего процесса и сообщает выходное состояние.|

1. Любой bash-скрипт должен начинаться со строки:

    #!/bin/bash

в этой строке после #! указывается путь к bash-интерпретатору, поэтому если он у вас установлен в другом месте(где, вы можете узнать набрав whereis bash) поменяйте её на ваш путь.
2. Коментарии начинаются с символа # (кроме первой строки).
3. В bash переменные не имеют типа(о них речь пойдет ниже)

    #!/bin/bash
    
    parametr1=$1
    script_name=$0
    echo "Вы запустили скрипт с именем $script_name и параметром $parametr1" 
    echo 'Вы запустили скрипт с именем $script_name и параметром $parametr1' # в одинарных кавычках не происходит подстановки переменных.
    exit 0

### Preset variables

|Variable|Value|
|------|--------|
|$DIRSTACK | содержимое вершины стека каталогов|
|$EDITOR | текстовый редактор по умолчанию|
|$EUID | Эффективный UID. Если вы использовали программу su для выполнения команд от другого пользователя, то эта переменная содержит UID этого пользователя, в то время как...|
|$UID | ...содержит реальный идентификатор, который устанавливается только при логине.|
|$FUNCNAME | имя текущей функции в скрипте.|
|$GROUPS | массив групп к которым принадлежит текущий пользователь|
|$HOME | домашний каталог пользователя|
|$HOSTNAME | ваш hostname|
|$HOSTTYPE | архитектура машины.|
|$LC_CTYPE | внутренняя переменная, котороя определяет кодировку символов|
|$OLDPWD | прежний рабочий каталог|
|$OSTYPE | тип ОС|
|$PATH | путь поиска программ|
|$PPID | идентификатор родительского процесса|
|$SECONDS | время работы скрипта(в сек.)|
|$# | общее количество параметров переданных скрипту|
|$* | все аргументы переданыне скрипту(выводятся в строку)|
|$@ | тоже самое, что и предыдущий, но параметры выводятся в столбик|
|$! | PID последнего запущенного в фоне процесса|
|$$ | PID самого скрипта|

### if

    if [[ "$source" -eq "$dest" ]] # -eq - логическое сравнение обозначающие "равны"
    then
    echo "Применик $dest и источник $source один и тот же файл!" 
    exit 1 # (1 - код ошибки)
    else
    cp $source $dest
    echo "Удачное копирование!"
    fi # окончание условия.


### Структура if-then-else:


    if <команда или набор команд возвращающих код возврата(0 или 1)>
    then
    <если выражение после if истино, то выполняется этот блок>
    else
    <если выражение после if ложно, тот этот>


В качестве команд возвращающих код возврата могут выступать структуры [[ , [ , test, (( )) или любая другая(или несколько) linux-команда.


test - используется для логического сравнения. после выражения, неоьбходима закрывающая скобка "]"


[ - синоним команды test


[[ - расширенная версия "[" (начиная с версии 2.02)(как в примере), внутри которой могут быть использованы || (или), & (и). должна иметь закрывающуб скобку "]]"


(( )) - математическое сравнение.


Для построения многоярусных условий вида:

    if ...
    then ....
    else
    if ....
    then....
    else ....

Для краткости и читаемости кода, можно использовать структуру:

    if ..
    then ...
    elif ...
    then ...
    elif ...

### Условия. Множественный выбор

Если необходимо сравнивать какоую-то одну переменную с большим количеством параметров, то целесообразней использовать оператор case.

    #!/bin/bash
    echo "Выберите редатор для запуска:"
    echo "1 Запуск программы nano"
    echo "2 Запуск программы vi"
    echo "3 Запуск программы emacs"
    echo "4 Выход"
    read doing #здесь мы читаем в переменную $doing со стандартного ввода

    case $doing in
    1)
    /usr/bin/nano # если $doing содержит 1, то запустить nano
    ;;
    2)
    /usr/bin/vi # если $doing содержит 2, то запустить vi
    ;;
    3)
    /usr/bin/emacs # если $doing содержит 3, то запустить emacs
    ;;
    4)
    exit 0
    ;;
    *) #если введено с клавиатуры то, что в case не описывается, выполнять следующее:
    echo "Введено неправильное действие"

    esac #окончание оператора case.


Результат работы:

    ite@ite-desktop:~$ ./menu2.sh
    Выберите редатор для запуска:
    1 Запуск программы nano
    2 Запуск программы vi
    3 Запуск программы emacs
    4 Выход

После выбор цифры и нажатия Enter запуститься тот редактор, который вы выбрали


Приведу список логических операторв, которые используются для конструкции if-then-else-fi:

    -z # строка пуста
    -n # строка не пуста
    =, (==) # строки равны
    != # строки неравны
    -eq # равно
    -ne # неравно
    -lt,(< ) # меньше
    -le,(<=) # меньше или равно
    -gt,(>) #больше
    -ge,(>=) #больше или равно
    ! #отрицание логического выражения
    -a,(&&) #логическое «И»
    -o,(||) # логическое «ИЛИ»
